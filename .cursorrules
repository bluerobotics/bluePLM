# BluePDM Cursor Rules

> Cursor AI reads this file for context. These rules maintain consistency and follow best practices.

## Critical Rules
⚠️ **ALWAYS update `supabase/schema.sql` when making database changes.** This file is the source of truth and must stay in sync with all migrations.

⚠️ **ALWAYS bump schema version when adding/modifying tables or columns.** This requires updates in TWO places:
   1. `supabase/schema.sql`: Update version history comment, change INSERT to new version, add UPDATE for migrations
   2. `src/lib/schemaVersion.ts`: Update `EXPECTED_SCHEMA_VERSION` constant and add entry to `VERSION_DESCRIPTIONS`
   Both files must stay in sync or users will see "database newer/older than app" warnings!

⚠️ **Sidebar text must be left-aligned.** All text in `ActivityBar.tsx` must use `text-left`. Never center-justify sidebar labels.

⚠️ **ALWAYS update documentation for user-facing features.** When building new features, update the `docs/` folder with guides and feature descriptions. Docs auto-deploy to docs.blueplm.io on release.

⚠️ **ALWAYS update version before pushing a tag.** Before creating a git tag, update `package.json` version AND add a `CHANGELOG.md` entry. The tag version must match `package.json`. Run `npm install` to update lockfile if dependencies changed.

⚠️ **ALWAYS run typecheck before pushing a tag.** Run `npm run typecheck` to verify no TypeScript errors before creating and pushing a git tag.

## Tech Stack
Frontend: React 19, TypeScript, Zustand, Tailwind CSS, Vite
Backend: Supabase (PostgreSQL, Auth, Storage, Realtime)
Desktop: Electron 34, IPC via preload script
Native: C# SolidWorks add-in, C++ eDrawings module

## Project Structure
src/components/ - React components (sidebar views in subdir)
src/lib/ - Business logic (commands/, supabase.ts, fileService.ts)
src/stores/ - Zustand stores (pdmStore.ts)
src/types/ - TypeScript definitions
electron/ - Main process (main.ts, preload.ts)
supabase/ - Database migrations and schema.sql

## Coding Conventions

### TypeScript
- Strict mode always enabled
- Prefer explicit types over `any`, use `unknown` when truly unknown
- Path aliases: `@/` for `src/`
- Naming: PascalCase (components, types), camelCase (functions, vars), UPPER_SNAKE_CASE (constants)
- Remove unused imports/variables/parameters

### React
- Functional components with hooks only
- State: `useState` (local UI), `usePDMStore` (global), React Query (when used for server state)
- `useEffect`: Always include cleanup, include all dependencies, avoid infinite loops
- `useMemo`/`useCallback`: Only for expensive computations or memoized children
- Component patterns: Controlled inputs, compound components, avoid HOCs/render props
- Hooks rules: Top level only, custom hooks start with `use`

### File Organization
- One component per file, co-locate related components
- Named exports (utilities), default exports (components)
- Imports: external → internal → relative
- Avoid barrel exports unless necessary

### Styling
- Tailwind CSS only (no CSS modules, styled-components)
- Use PDM theme: `pdm-bg`, `pdm-fg`, `pdm-accent`, `pdm-border`, status colors (`pdm-success`, `pdm-warning`, `pdm-error`, `pdm-info`)
- Desktop-first, dark theme only
- No inline styles

### State Management (Zustand)
- Single store: `src/stores/pdmStore.ts`
- Use `persist` middleware for user preferences
- Actions as functions, use `set` (never mutate directly)
- Use selectors to avoid unnecessary re-renders

### Electron IPC
- All IPC via `window.electronAPI` (defined in `src/electron.d.ts`)
- Main → Renderer: Event listeners (`onUpdateAvailable`)
- Renderer → Main: Promise-based calls (`listWorkingFiles()`)
- Security: Never expose Node.js APIs, context isolation enabled, validate IPC messages

### Supabase
- Client singleton from `src/lib/supabase.ts`
- Queries: `.select()` with explicit columns (avoid `select('*')`)
- Always check `error` field in responses
- Realtime: Use subscriptions from `src/lib/realtime.ts`
- Types: Generate from schema (`src/types/database.ts`)
- RLS: Respect policies, test with different roles
- Pagination: Use `.range()` for large datasets
- Storage: Signed URLs for private files

### File Operations
- Platform-agnostic paths: Use `buildFullPath()` helper, normalize with `.replace(/[/\\]/g, sep)`
- Windows: Case-insensitive matching
- Hashes: SHA-256 for content hashing
- Read-only: Set on files not checked out by current user
- All file ops are async with proper error handling

### Error Handling
- User-facing: Toast notifications
- Logging: `window.electronAPI?.log()` for structured logs
- Console: `console.log` (debug), `console.error` (errors)
- Graceful degradation: Handle offline mode
- Try-catch: Wrap all async operations
- Error boundaries: Wrap major sections (when implemented)

### Performance
- Parallel loading: Local and server files in parallel
- Background tasks: Compute hashes after initial render
- Debouncing: File watcher events (1 second)
- Lazy loading: User info for checked-out files
- Memoization: Only for expensive computations

## Common Patterns

### Adding Component
1. Create in `src/components/` or subdirectory
2. TypeScript with prop types
3. Tailwind classes only
4. Import from `@/` alias
5. Default export

### Adding Store Action
1. Add to `pdmStore.ts`
2. Use Zustand `set` function
3. Consider `persist` for user preferences
4. Add TypeScript types

### Adding CLI Command
1. Handler in `src/lib/commands/handlers/`
2. Register in `src/lib/commands/index.ts`
3. Use `executeTerminalCommand` parser
4. Return structured results

### Database Changes
1. **ALWAYS update `supabase/schema.sql` FIRST** (source of truth)
2. **Bump schema version in schema.sql** (update version history comment, INSERT value, add UPDATE for migrations)
3. **Bump schema version in `src/lib/schemaVersion.ts`** (update `EXPECTED_SCHEMA_VERSION` and `VERSION_DESCRIPTIONS`)
4. Create migration file in `supabase/` (descriptive name)
5. Update `src/types/database.ts` if schema changes
6. Test with local Supabase
7. Update RLS policies and indexes

### API Design (Fastify)
- RESTful conventions
- JSON Schema validation on all requests
- Consistent error responses
- JWT auth via Supabase
- Rate limiting
- OpenAPI/Swagger docs at `/docs`
- Signed URLs for file access

## Best Practices
- Readability: Self-documenting code, clear variable names
- Comments: Complex logic only, explain "why" not "what"
- DRY: Extract common logic
- Single Responsibility: One thing per function/component
- Security: No secrets in code, validate inputs, sanitize paths
- Accessibility: Keyboard navigation, ARIA labels, semantic HTML, color contrast
- Git: Conventional commits (`type(scope): subject`), feature branches, focused PRs

## Things to Avoid
❌ `any` type without reason
❌ Mix CSS frameworks (Tailwind only)
❌ Expose Node.js APIs to renderer
❌ Block UI thread with heavy operations
❌ Hardcode paths (use platform detection)
❌ Ignore TypeScript errors
❌ Commit `.env` files or secrets
❌ Inline styles (use Tailwind)
❌ Unnecessary abstractions
❌ Mutate Zustand state directly (use `set`)

## Project-Specific Choices
- Zustand over Redux (single store pattern)
- Tailwind only (no CSS modules/styled-components)
- Custom components (no Material-UI/library)
- Manual testing focus (no test framework yet)
- Direct Supabase access (desktop app, not via API)

## When Making Changes
1. Check existing patterns in codebase
2. Follow established conventions
3. Test on target platform(s)
4. Update TypeScript types
5. Document complex logic
6. Consider performance impact
7. Respect project choices (don't introduce Redux if Zustand works)
8. Security first (path traversal, XSS, etc.)
9. **Refactoring**: Be extra careful not to lose existing functionality - test thoroughly, preserve edge cases, maintain backward compatibility
10. **Documentation**: Update `docs/` folder for user-facing features (auto-deploys to docs.blueplm.io on release)
